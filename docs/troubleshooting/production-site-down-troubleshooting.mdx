---
sidebar_position: 1
title: "Production Site Down - Emergency Troubleshooting"
description: "Emergency procedures for handling production site outages and deployment issues"
date: "2025-01-27"
category: "general"
tags: ["production", "outage", "deployment", "emergency", "troubleshooting"]
---

import TroubleshootingItem from "@site/src/components/HomepageFeatures/troubleshootingitem";

# Production Site Down - Emergency Troubleshooting

**Date:** January 27, 2025  
**Category:** General  
**Tags:** Production, Outage, Deployment, Emergency, Troubleshooting

## Problem Description

**Context:** Production site experiencing downtime requiring immediate attention and emergency deployment procedures through SleakOps platform.

**Observed Symptoms:**

- Complete site outage ("Se nos cayÃ³ el sitio")
- Site under construction status
- Urgent production environment issues
- Need for emergency deployment coordination
- Multiple team members required for resolution

**Relevant Configuration:**

- Environment: Production
- Platform: SleakOps with Bitbucket integration
- Deployment method: Bitbucket pipelines
- Team coordination: Required for production changes

**Error Conditions:**

- Production site completely down
- Emergency deployment needed
- Multiple stakeholders involved in resolution
- Time-sensitive restoration required

## Detailed Solution

<TroubleshootingItem id="immediate-assessment" summary="Immediate Site Assessment">

When facing a production outage:

1. **Verify the scope of the outage**:

   - Check if it's a complete site failure or partial functionality
   - Verify DNS resolution and basic connectivity
   - Check monitoring dashboards for alerts

2. **Gather initial information**:

   - Recent deployments or changes
   - Error logs from applications
   - Infrastructure status (pods, services, ingress)

3. **Establish communication**:
   - Create emergency communication channel
   - Notify all relevant stakeholders
   - Document timeline of events

</TroubleshootingItem>

<TroubleshootingItem id="emergency-deployment" summary="Emergency Deployment Procedures">

For emergency deployments in SleakOps:

1. **Coordinate with team**:

   ```bash
   # Before any production deployment, ensure team coordination
   # Use communication channels to announce deployment
   ```

2. **Deploy through SleakOps**:

   - Access SleakOps dashboard
   - Navigate to the affected project
   - Select the production environment
   - Choose "Deploy" with the last known good version

3. **Alternative deployment via Bitbucket**:

   ```yaml
   # If deploying through Bitbucket pipelines
   # Ensure the pipeline targets the correct environment
   pipelines:
     branches:
       main:
         - step:
             name: Emergency Deploy to Production
             script:
               - echo "Emergency deployment initiated"
               -  # Your deployment commands here
   ```

4. **Monitor deployment progress**:
   - Watch deployment logs in real-time
   - Monitor application health checks
   - Verify service restoration

</TroubleshootingItem>

<TroubleshootingItem id="rollback-procedures" summary="Rollback Procedures">

If the emergency deployment doesn't resolve the issue:

1. **Immediate rollback**:

   - In SleakOps: Use "Rollback" feature to previous stable version
   - Document the rollback decision and timing

2. **Verify rollback success**:

   ```bash
   # Check application status
   kubectl get pods -n production
   kubectl get services -n production

   # Verify application health
   curl -I https://your-production-site.com
   ```

3. **Post-rollback actions**:
   - Confirm site functionality
   - Notify stakeholders of temporary resolution
   - Begin root cause analysis

</TroubleshootingItem>

<TroubleshootingItem id="team-coordination" summary="Team Coordination During Outages">

Effective coordination during production incidents:

1. **Establish incident commander**:

   - Designate one person to coordinate efforts
   - All deployment decisions go through this person
   - Maintain clear communication channels

2. **Role assignments**:

   - **Incident Commander**: Overall coordination
   - **Technical Lead**: Hands-on troubleshooting
   - **Communications**: Stakeholder updates
   - **Documentation**: Timeline and actions taken

3. **Communication protocols**:

   - Use video calls for real-time coordination
   - Maintain written updates in shared channels
   - Set regular update intervals (every 15-30 minutes)

4. **Decision making**:
   - Quick consensus on deployment actions
   - Clear go/no-go decisions
   - Document all major decisions with timestamps

</TroubleshootingItem>

<TroubleshootingItem id="post-incident" summary="Post-Incident Actions">

After resolving the production outage:

1. **Immediate verification**:

   - Comprehensive functionality testing
   - Performance monitoring for 1-2 hours
   - User acceptance verification

2. **Documentation**:

   - Complete incident timeline
   - Root cause analysis
   - Actions taken and their outcomes
   - Lessons learned

3. **Follow-up improvements**:

   - Review deployment procedures
   - Enhance monitoring and alerting
   - Update emergency response procedures
   - Schedule post-mortem meeting

4. **Stakeholder communication**:
   - Send resolution notification
   - Provide brief summary of cause and fix
   - Share timeline for detailed post-mortem

</TroubleshootingItem>

<TroubleshootingItem id="prevention-measures" summary="Prevention and Preparedness">

To minimize future production outages:

1. **Deployment best practices**:

   - Always use staging environment first
   - Implement blue-green deployments
   - Maintain rollback procedures
   - Use feature flags for risky changes

2. **Monitoring and alerting**:

   ```yaml
   # Example monitoring configuration
   alerts:
     - name: site-down
       condition: http_status != 200
       duration: 1m
       severity: critical
       notifications:
         - slack
         - email
   ```

3. **Emergency preparedness**:

   - Maintain updated emergency contact list
   - Regular disaster recovery drills
   - Pre-defined communication channels
   - Emergency deployment procedures documentation

4. **Team readiness**:
   - Cross-training on deployment procedures
   - Access permissions for key team members
   - Emergency escalation procedures
   - Regular review of incident response plans

</TroubleshootingItem>

<TroubleshootingItem id="infrastructure-diagnostics" summary="Infrastructure-level diagnostics">

When site outages occur, perform these infrastructure checks:

1. **Cloud provider status**:

```bash
# Check AWS service health (if using AWS)
aws sts get-caller-identity
aws ec2 describe-instances --query 'Reservations[*].Instances[*].[InstanceId,State.Name]'

# Verify load balancer status
aws elbv2 describe-load-balancers
aws elbv2 describe-target-health --target-group-arn <target-group-arn>
```

2. **Kubernetes cluster health**:

```bash
# Check cluster nodes
kubectl get nodes
kubectl describe nodes | grep -i "ready\|condition"

# Verify core services
kubectl get pods -n kube-system
kubectl get componentstatuses

# Check cluster events
kubectl get events --all-namespaces --sort-by=.metadata.creationTimestamp | tail -20
```

3. **Network connectivity**:

```bash
# Test DNS resolution
dig your-domain.com
nslookup your-domain.com

# Check SSL certificates
echo | openssl s_client -connect your-domain.com:443 2>/dev/null | openssl x509 -noout -dates

# Test connectivity from different locations
curl -I https://your-domain.com
```

4. **Database connectivity**:

```bash
# Check database status (PostgreSQL example)
kubectl exec -it <db-pod> -- pg_isready
kubectl exec -it <db-pod> -- psql -c "SELECT version();"

# Check database connections
kubectl exec -it <app-pod> -- nc -zv database-service 5432
```

</TroubleshootingItem>

<TroubleshootingItem id="application-level-debugging" summary="Application-level debugging">

Debug application-specific issues during outages:

1. **Application pod analysis**:

```bash
# Check pod status and events
kubectl get pods -n production
kubectl describe pod <failing-pod> -n production

# Examine application logs
kubectl logs <pod-name> -n production --tail=100
kubectl logs <pod-name> -n production --previous  # Previous container logs
```

2. **Configuration verification**:

```bash
# Check ConfigMaps and Secrets
kubectl get configmaps -n production
kubectl get secrets -n production

# Verify environment variables
kubectl exec -it <pod-name> -n production -- env | sort
```

3. **Resource utilization**:

```bash
# Check resource usage
kubectl top pods -n production
kubectl top nodes

# Check resource quotas
kubectl describe quota -n production
kubectl describe limitrange -n production
```

4. **Service connectivity**:

```bash
# Test internal service connections
kubectl exec -it <pod-name> -n production -- wget -qO- http://internal-service:port/health

# Check service endpoints
kubectl get endpoints -n production
kubectl describe service <service-name> -n production
```

</TroubleshootingItem>

<TroubleshootingItem id="emergency-communication" summary="Emergency communication templates">

Use these communication templates during outages:

**Initial incident notification:**

```
ðŸš¨ PRODUCTION INCIDENT ALERT ðŸš¨

Status: Site down detected
Time: [TIMESTAMP]
Impact: Complete site outage
Team: Incident response team activated
ETA for update: 15 minutes

Incident Commander: [NAME]
Next update: [TIME]
```

**Progress updates:**

```
ðŸ”„ INCIDENT UPDATE

Status: Investigating
Time: [TIMESTAMP]
Progress: [CURRENT ACTIONS]
Impact: [CURRENT IMPACT ASSESSMENT]

Actions taken:
- [ACTION 1]
- [ACTION 2]

Next steps:
- [NEXT ACTION]

Next update: [TIME]
```

**Resolution notification:**

```
âœ… INCIDENT RESOLVED

Status: Site restored
Time: [TIMESTAMP]
Duration: [TOTAL DOWNTIME]
Root cause: [BRIEF CAUSE]

Resolution:
- [ACTIONS THAT FIXED THE ISSUE]

Follow-up:
- Post-mortem scheduled for [DATE/TIME]
- Preventive measures to be implemented
```

**Escalation procedures:**

```bash
# Emergency contact hierarchy
1. Incident Commander
2. Technical Lead/DevOps Lead
3. Engineering Manager
4. CTO/Technical Director
5. Business Stakeholders

# Communication channels
- Primary: Slack #incidents
- Secondary: WhatsApp group
- External: Customer status page
```

</TroubleshootingItem>

<TroubleshootingItem id="detailed-recovery-checklist" summary="Detailed recovery verification checklist">

Use this comprehensive checklist to verify full system recovery:

**Application Level:**

```bash
â–¡ All pods are running and ready
â–¡ Health check endpoints responding (200 OK)
â–¡ Application logs show normal operation
â–¡ No error spikes in monitoring dashboards
â–¡ Resource utilization within normal ranges
```

**Infrastructure Level:**

```bash
â–¡ All cluster nodes are ready
â–¡ Load balancer is healthy and routing traffic
â–¡ DNS resolution is working correctly
â–¡ SSL certificates are valid and not expired
â–¡ CDN (if applicable) is serving content
```

**Data Layer:**

```bash
â–¡ Database connections are stable
â–¡ Database queries are performing normally
â–¡ Backup systems are operational
â–¡ Data integrity checks pass
â–¡ Cache layers are functioning
```

**User Experience:**

```bash
â–¡ Website loads completely within acceptable time
â–¡ All critical user flows work end-to-end
â–¡ Payment systems are operational (if applicable)
â–¡ User authentication/login works
â–¡ Mobile app connectivity (if applicable)
```

**Business Functions:**

```bash
â–¡ Order processing works (if e-commerce)
â–¡ Email notifications are sending
â–¡ Third-party integrations are working
â–¡ Monitoring and alerting systems are operational
â–¡ Backup and disaster recovery systems are verified
```

**Sign-off checklist:**

```bash
â–¡ Technical team confirms full restoration
â–¡ QA team verifies critical flows
â–¡ Business stakeholders approve go-live
â–¡ Customer support team notified of resolution
â–¡ Documentation updated with incident details
```

</TroubleshootingItem>

<TroubleshootingItem id="automated-recovery" summary="Implementing automated recovery mechanisms">

Set up automated systems to handle future outages:

1. **Health check automation**:

```yaml
# Kubernetes deployment with robust health checks
spec:
  template:
    spec:
      containers:
        - name: app
          livenessProbe:
            httpGet:
              path: /health
              port: 8080
            initialDelaySeconds: 30
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 3
          readinessProbe:
            httpGet:
              path: /ready
              port: 8080
            initialDelaySeconds: 5
            periodSeconds: 5
            timeoutSeconds: 3
            failureThreshold: 3
```

2. **Auto-scaling configuration**:

```yaml
# Horizontal Pod Autoscaler
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: app-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: app-deployment
  minReplicas: 3
  maxReplicas: 20
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
    - type: Resource
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: 80
```

3. **Circuit breaker implementation**:

```yaml
# Example circuit breaker configuration
circuit_breaker:
  failure_threshold: 5
  recovery_timeout: 30s
  success_threshold: 3
  timeout: 10s
```

4. **Automated alerting**:

```yaml
# Prometheus alerting rules
groups:
  - name: production-alerts
    rules:
      - alert: SiteDown
        expr: probe_success{job="blackbox"} == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Production site is down"
          description: "Site has been down for more than 1 minute"

      - alert: HighErrorRate
        expr: rate(http_requests_total{status=~"5.."}[5m]) > 0.1
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "High error rate detected"
```

</TroubleshootingItem>

---

_This FAQ was automatically generated on January 27, 2025 based on a real user query._
