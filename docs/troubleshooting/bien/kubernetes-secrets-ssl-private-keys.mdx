---
sidebar_position: 3
title: "Kubernetes Secrets for SSL Private Keys"
description: "How to securely store and mount SSL private keys using Kubernetes Secrets in SleakOps"
date: "2024-12-19"
category: "project"
tags: ["kubernetes", "secrets", "ssl", "security", "volumes"]
---

import TroubleshootingItem from "@site/src/components/HomepageFeatures/troubleshootingitem";

# Kubernetes Secrets for SSL Private Keys

**Date:** December 19, 2024  
**Category:** Project  
**Tags:** Kubernetes, Secrets, SSL, Security, Volumes

## Problem Description

**Context:** Users need to securely store SSL private keys in their Kubernetes environment and mount them as files within containers with proper access restrictions.

**Observed Symptoms:**

- Need to store SSL private keys securely in Kubernetes
- Requirement to mount secrets as files (not environment variables)
- Need to restrict access to authorized pods only
- Requirement for proper file permissions on mounted secrets

**Relevant Configuration:**

- Platform: SleakOps Kubernetes environment
- Secret type: SSL private keys
- Mount requirement: File-based (not environment variables)
- Security level: High priority with restricted access

**Error Conditions:**

- Default VariableGroup creates environment variables, not files
- Need specific configuration for file-based secret mounting
- Requires proper security practices for SSL key management

## Detailed Solution

<TroubleshootingItem id="variable-group-approach" summary="Using VariableGroup for Environment Variables">

The standard approach in SleakOps is to use VariableGroups, which expose secrets as environment variables:

1. **Create a VariableGroup:**

   - Go to your project in SleakOps
   - Navigate to **VariableGroups**
   - Create a new VariableGroup
   - Add your SSL private key as a variable

2. **Assign to Execution:**
   - Assign the VariableGroup to specific executions
   - Or leave it "global" to expose to all executions in the project

**Note:** This method exposes the secret as an environment variable, not as a file.

</TroubleshootingItem>

<TroubleshootingItem id="volume-based-approach" summary="Creating Volumes for File-Based Secrets">

For file-based secret mounting (recommended for SSL keys), use the volume approach:

1. **Navigate to Project Details:**

   - Go to **Projects** → **Details**
   - Find the **Volumes** section

2. **Create a Secret Volume:**

   - Create a new volume of type "Secret"
   - Upload or paste your SSL private key content
   - Configure the mount path where the file should appear

3. **Example Configuration:**
   ```yaml
   # Volume configuration
   name: ssl-private-key
   type: secret
   mountPath: /etc/ssl/private/
   fileName: private.key
   permissions: 0600
   ```

</TroubleshootingItem>

<TroubleshootingItem id="security-best-practices" summary="Security Best Practices">

When working with SSL private keys in Kubernetes:

1. **File Permissions:**

   - Set restrictive permissions (0600 or 0400)
   - Ensure only the application user can read the key

2. **Access Control:**

   - Use Kubernetes RBAC to limit pod access
   - Only mount secrets to pods that need them
   - Avoid exposing keys as environment variables

3. **Storage Security:**

   - Use Kubernetes native secret encryption at rest
   - Rotate keys regularly
   - Monitor access to secret resources

4. **Example Secure Configuration:**
   ```yaml
   # Secure volume mount
   volumes:
     - name: ssl-key-volume
       secret:
         secretName: ssl-private-key
         defaultMode: 0400
         items:
           - key: private.key
             path: private.key
             mode: 0400
   ```

</TroubleshootingItem>

<TroubleshootingItem id="implementation-steps" summary="Step-by-Step Implementation">

**Step 1: Prepare Your SSL Key**

- Ensure your private key is in PEM format
- Remove any extra whitespace or formatting
- Test the key validity before uploading

**Step 2: Create the Secret Volume in SleakOps**

1. Navigate to **Projects** → **[Your Project]** → **Details**
2. Scroll to **Volumes** section
3. Click **Add Volume**
4. Select **Secret** type
5. Configure:
   - **Name:** `ssl-private-key`
   - **Mount Path:** `/etc/ssl/private/`
   - **File Name:** `private.key`
   - **Content:** Paste your private key
   - **Permissions:** `0600`

**Step 3: Reference in Your Application**

```dockerfile
# In your Dockerfile or application
# The key will be available at /etc/ssl/private/private.key
COPY --from=secrets /etc/ssl/private/private.key /app/ssl/
```

**Step 4: Verify Access**

- Deploy your application
- Check that the file exists at the specified path
- Verify file permissions are correct
- Test SSL functionality

</TroubleshootingItem>

<TroubleshootingItem id="troubleshooting" summary="Common Issues and Troubleshooting">

**Issue 1: File Not Found**

- Verify the mount path is correct
- Check that the volume is properly attached to the pod
- Ensure the secret was created successfully

**Issue 2: Permission Denied**

- Check file permissions (should be 0600 or 0400)
- Verify the application user has read access
- Ensure the mount path directory exists

**Issue 3: Invalid Key Format**

- Verify the key is in proper PEM format
- Check for extra characters or formatting issues
- Test the key outside of Kubernetes first

**Debugging Commands:**

```bash
# Check if secret exists
kubectl get secrets

# Verify volume mount
kubectl describe pod <pod-name>

# Check file permissions inside pod
kubectl exec <pod-name> -- ls -la /etc/ssl/private/
```

</TroubleshootingItem>

---

_This FAQ was automatically generated on December 19, 2024 based on a real user query._
