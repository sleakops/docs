---
sidebar_position: 15
title: "Database Restore in Pod Environment"
description: "Procedures for restoring database dumps in Kubernetes pods with connection resilience"
date: "2024-03-21"
category: "dependency"
tags: ["database", "restore", "dump", "pod", "tmux", "kubernetes"]
---

import TroubleshootingItem from "@site/src/components/HomepageFeatures/troubleshootingitem";

# Database Restore in Pod Environment

**Date:** March 21, 2024  
**Category:** Dependency  
**Tags:** Database, Restore, Dump, Pod, Tmux, Kubernetes

## Problem Description

**Context:** When performing database restoration operations in Kubernetes pods, users need reliable procedures to handle large dump files while maintaining connection stability during long-running restore processes.

**Observed Symptoms:**

- Connection drops during long database restore operations
- Volume space issues due to accumulated old dump files
- Need for session persistence during restore processes
- Requirement for monitoring restore progress

**Relevant Configuration:**

- Environment: Production database restoration
- Platform: Kubernetes pods
- Tools: Database dump files, tmux for session management
- Storage: Pod volumes with limited space

**Error Conditions:**

- Connection timeouts during restore operations
- Insufficient disk space for dump files
- Process interruption due to network issues
- Loss of restore progress when connection drops

## Detailed Solution

<TroubleshootingItem id="improved-restore-script" summary="Enhanced Database Restore Script">

The improved restore script includes several optimizations:

```bash
#!/bin/bash
# Enhanced database restore script

set -e

# Configuration
DUMP_DIR="/data/dumps"
LOG_FILE="/data/logs/restore_$(date +%Y%m%d_%H%M%S).log"
MAX_DUMP_AGE_DAYS=7

# Function to clean old dumps
clean_old_dumps() {
    echo "Cleaning dumps older than ${MAX_DUMP_AGE_DAYS} days..." | tee -a $LOG_FILE
    find $DUMP_DIR -name "*.sql" -type f -mtime +$MAX_DUMP_AGE_DAYS -delete
    find $DUMP_DIR -name "*.dump" -type f -mtime +$MAX_DUMP_AGE_DAYS -delete
    echo "Old dumps cleaned successfully" | tee -a $LOG_FILE
}

# Function to check available space
check_disk_space() {
    AVAILABLE_SPACE=$(df $DUMP_DIR | awk 'NR==2 {print $4}')
    REQUIRED_SPACE=1048576  # 1GB in KB

    if [ $AVAILABLE_SPACE -lt $REQUIRED_SPACE ]; then
        echo "Warning: Low disk space. Available: ${AVAILABLE_SPACE}KB" | tee -a $LOG_FILE
        clean_old_dumps
    fi
}

# Main restore function
restore_database() {
    local dump_file=$1
    local database_name=$2

    echo "Starting database restore: $dump_file -> $database_name" | tee -a $LOG_FILE
    echo "Start time: $(date)" | tee -a $LOG_FILE

    # Restore with progress monitoring
    pv $dump_file | psql -h $DB_HOST -U $DB_USER -d $database_name 2>&1 | tee -a $LOG_FILE

    echo "Restore completed at: $(date)" | tee -a $LOG_FILE
}

# Pre-restore checks
check_disk_space
clean_old_dumps

# Execute restore
restore_database "$1" "$2"
```

</TroubleshootingItem>

<TroubleshootingItem id="tmux-session-management" summary="Using tmux for Connection Resilience">

To handle connection drops during long restore operations, use tmux:

```bash
# Start a new tmux session for the restore
kubectl exec -it <pod-name> -- tmux new-session -d -s restore

# Attach to the session
kubectl exec -it <pod-name> -- tmux attach-session -t restore

# Inside the tmux session, run the restore
./restore_script.sh /data/dumps/production_dump.sql production_db

# Detach from session (Ctrl+b, then d)
# Session continues running even if connection drops

# Reattach later to check progress
kubectl exec -it <pod-name> -- tmux attach-session -t restore

# List all sessions
kubectl exec -it <pod-name> -- tmux list-sessions
```

**Benefits of using tmux:**

- Session persistence across connection drops
- Ability to monitor progress remotely
- Multiple windows for parallel operations
- Session sharing between team members

</TroubleshootingItem>

<TroubleshootingItem id="volume-space-management" summary="Managing Pod Volume Space">

To prevent volume space issues during restore operations:

```yaml
# Pod configuration with adequate storage
apiVersion: v1
kind: Pod
metadata:
  name: db-restore-pod
spec:
  containers:
    - name: restore-container
      image: postgres:14
      volumeMounts:
        - name: dump-storage
          mountPath: /data/dumps
        - name: logs-storage
          mountPath: /data/logs
      resources:
        requests:
          storage: "50Gi" # Adequate space for dumps
  volumes:
    - name: dump-storage
      persistentVolumeClaim:
        claimName: dump-pvc
    - name: logs-storage
      emptyDir: {}
```

**Space management commands:**

```bash
# Check current usage
kubectl exec -it <pod-name> -- df -h /data/dumps

# Clean old dumps manually
kubectl exec -it <pod-name> -- find /data/dumps -name "*.sql" -mtime +7 -delete

# Monitor space during restore
kubectl exec -it <pod-name> -- watch "df -h /data/dumps"
```

</TroubleshootingItem>

<TroubleshootingItem id="monitoring-restore-progress" summary="Monitoring Restore Progress">

To monitor the restore process effectively:

```bash
# Using pv (pipe viewer) for progress monitoring
kubectl exec -it <pod-name> -- pv /data/dumps/large_dump.sql | psql -h localhost -U postgres -d target_db

# Monitor logs in real-time
kubectl exec -it <pod-name> -- tail -f /data/logs/restore_*.log

# Check database size growth
kubectl exec -it <pod-name> -- psql -h localhost -U postgres -c "SELECT pg_size_pretty(pg_database_size('target_db'));"

# Monitor active connections
kubectl exec -it <pod-name> -- psql -h localhost -U postgres -c "SELECT count(*) FROM pg_stat_activity WHERE datname='target_db';"
```

**Progress monitoring script:**

```bash
#!/bin/bash
# progress_monitor.sh

DB_NAME=$1
while true; do
    SIZE=$(psql -h localhost -U postgres -t -c "SELECT pg_size_pretty(pg_database_size('$DB_NAME'));")
    echo "$(date): Database size: $SIZE"
    sleep 30
done
```
