---
sidebar_position: 3
title: "Migración de Base de Datos de Heroku a AWS RDS"
description: "Guía completa para migrar bases de datos PostgreSQL de Heroku a AWS RDS usando DMS y pg_restore"
date: "2024-12-19"
category: "dependency"
tags:
  ["base de datos", "migración", "heroku", "aws", "rds", "postgresql", "dms"]
---

import TroubleshootingItem from "@site/src/components/HomepageFeatures/troubleshootingitem";

# Migración de Base de Datos de Heroku a AWS RDS

**Fecha:** 19 de diciembre de 2024  
**Categoría:** Dependencia  
**Etiquetas:** Base de datos, Migración, Heroku, AWS, RDS, PostgreSQL, DMS

## Descripción del Problema

**Contexto:** Los usuarios necesitan migrar grandes bases de datos PostgreSQL desde Heroku a AWS RDS a través de la plataforma SleakOps, enfrentando volcados incompletos y discrepancias de tamaño entre la base de datos de origen y la restaurada.

**Síntomas Observados:**

- La restauración del volcado de Heroku resulta en un tamaño de base de datos menor (94GB vs 385GB en producción)
- La descarga estándar del volcado mediante curl puede estar incompleta
- Necesidad de acceso externo a la base de datos para herramientas de migración
- Requerimiento de configuración de AWS DMS para completar la migración

**Configuración Relevante:**

- Origen: Base de datos PostgreSQL en Heroku (385GB)
- Destino: AWS RDS PostgreSQL
- Tamaño del volcado restaurado: 94GB (incompleto)
- Método de migración: pg_restore con --jobs=8 --no-owner --no-acl

**Condiciones de Error:**

- Transferencia de datos incompleta usando métodos estándar de volcado de Heroku
- Desajuste de tamaño que indica pérdida de datos durante la migración
- Necesidad de replicación continua para sincronizar datos faltantes

## Solución Detallada

<TroubleshootingItem id="heroku-dump-limitations" summary="Entendiendo las limitaciones del volcado de Heroku">

El proceso estándar de volcado de Heroku puede no capturar todos los datos debido a:

1. **Limitaciones de tiempo de espera:** Bases de datos grandes pueden agotarse durante la generación del volcado
2. **Transacciones activas:** Datos escritos durante la creación del volcado podrían perderse
3. **Problemas de compresión:** Algunos tipos de datos pueden no comprimirse/descomprimirse correctamente
4. **Límites de conexión:** Heroku puede limitar operaciones de volcado que duren mucho tiempo

**Pasos de verificación:**

```bash
# Verificar el conteo de filas en ambas bases de datos
psql -h heroku-host -c "SELECT schemaname,tablename,n_tup_ins-n_tup_del as rowcount FROM pg_stat_user_tables ORDER BY rowcount DESC;"
psql -h rds-host -c "SELECT schemaname,tablename,n_tup_ins-n_tup_del as rowcount FROM pg_stat_user_tables ORDER BY rowcount DESC;"

# Comparar tamaños de base de datos
psql -h heroku-host -c "SELECT pg_size_pretty(pg_database_size(current_database()));"
psql -h rds-host -c "SELECT pg_size_pretty(pg_database_size(current_database()));"

# Verificar integridad del volcado
file latest.dump
pg_restore --list latest.dump | head -20
```

**Indicadores de volcado incompleto:**

- Diferencias significativas en el conteo de filas entre tablas
- Tamaños de base de datos que no coinciden proporcionalmente
- Errores durante pg_restore relacionados con datos faltantes
- Índices o constraints no restaurados correctamente

</TroubleshootingItem>

<TroubleshootingItem id="aws-dms-setup" summary="Configurando AWS DMS para migración continua">

El servicio de migración de bases de datos de AWS (DMS) puede manejar migraciones de bases de datos grandes con tiempo de inactividad mínimo:

**Requisitos previos:**

1. Crear instancia de replicación DMS
2. Configurar endpoint de origen (PostgreSQL en Heroku)
3. Configurar endpoint de destino (AWS RDS)
4. Establecer acceso externo a la base de datos

**Configuración de DMS:**

```json
{
  "replication-instance-class": "dms.t3.large",
  "replication-instance-id": "heroku-to-rds-migration",
  "storage-encrypted": true,
  "allocated-storage": 500,
  "vpc-security-group-ids": ["sg-xxxxxxxxx"],
  "replication-subnet-group-id": "dms-subnet-group"
}
```

**Configuración del endpoint de origen (Heroku):**

```json
{
  "endpoint-id": "heroku-postgres-source",
  "endpoint-type": "source",
  "engine-name": "postgres",
  "server-name": "heroku-postgres-host.compute-1.amazonaws.com",
  "port": 5432,
  "database-name": "database_name",
  "username": "heroku_user",
  "password": "heroku_password",
  "ssl-mode": "require"
}
```

**Configuración del endpoint de destino (RDS):**

```json
{
  "endpoint-id": "rds-postgres-target",
  "endpoint-type": "target",
  "engine-name": "postgres",
  "server-name": "rds-instance.region.rds.amazonaws.com",
  "port": 5432,
  "database-name": "database_name",
  "username": "rds_user",
  "password": "rds_password"
}
```

</TroubleshootingItem>

<TroubleshootingItem id="external-database-access" summary="Configurando acceso externo para herramientas de migración">

Para usar herramientas como DMS o migración manual, necesita configurar acceso externo en SleakOps:

**Pasos en SleakOps:**

1. **Navegar a Dependencias** → Seleccionar su base de datos PostgreSQL
2. **Configurar Acceso Externo:**
   - Habilitar "External Access"
   - Configurar security groups apropiados
   - Obtener endpoint y credenciales

```yaml
# Configuración de security group para DMS
SecurityGroupRules:
  - Type: Egress
    Protocol: TCP
    Port: 5432
    Destination: 0.0.0.0/0
  - Type: Ingress
    Protocol: TCP
    Port: 5432
    Source: dms-subnet-group-cidr
```

**Verificación de conectividad:**

```bash
# Probar conexión desde instancia DMS
psql -h rds-endpoint.region.rds.amazonaws.com -p 5432 -U username -d database_name -c "SELECT version();"

# Verificar que DMS puede acceder a Heroku
psql -h heroku-host.compute-1.amazonaws.com -p 5432 -U heroku_user -d database_name -c "SELECT version();"
```

</TroubleshootingItem>

<TroubleshootingItem id="migration-task-configuration" summary="Configurando la tarea de migración DMS">

**Configuración de tarea de migración completa:**

```json
{
  "migration-type": "full-load-and-cdc",
  "replication-task-id": "heroku-to-rds-full-migration",
  "source-endpoint-arn": "arn:aws:dms:region:account:endpoint:heroku-postgres-source",
  "target-endpoint-arn": "arn:aws:dms:region:account:endpoint:rds-postgres-target",
  "replication-instance-arn": "arn:aws:dms:region:account:rep:heroku-to-rds-migration",
  "table-mappings": {
    "rules": [
      {
        "rule-type": "selection",
        "rule-id": "1",
        "rule-name": "1",
        "object-locator": {
          "schema-name": "public",
          "table-name": "%"
        },
        "rule-action": "include"
      }
    ]
  }
}
```

**Configuración avanzada de tarea:**

```json
{
  "task-settings": {
    "TargetMetadata": {
      "SupportLobs": true,
      "FullLobMode": false,
      "LobChunkSize": 64,
      "LimitedSizeLobMode": true,
      "LobMaxSize": 32
    },
    "FullLoadSettings": {
      "CommitRate": 10000,
      "MaxFullLoadSubTasks": 8,
      "TransactionConsistencyTimeout": 600,
      "CreatePkAfterFullLoad": false
    },
    "ChangeDataCaptureSettings": {
      "StartFromTimestamp": "2024-12-19T00:00:00",
      "MemoryLimitTotal": 1024,
      "MemoryKeepTime": 60
    }
  }
}
```

</TroubleshootingItem>

<TroubleshootingItem id="data-validation" summary="Validación y verificación de datos migrados">

**Scripts de validación post-migración:**

```sql
-- Comparar conteo de tablas
SELECT 
    'Source' as database_type,
    schemaname,
    tablename,
    n_tup_ins - n_tup_del as row_count
FROM pg_stat_user_tables 
ORDER BY row_count DESC;

-- Verificar integridad referencial
SELECT 
    conname as constraint_name,
    conrelid::regclass as table_name,
    confrelid::regclass as referenced_table
FROM pg_constraint 
WHERE contype = 'f';

-- Validar secuencias
SELECT 
    sequencename,
    last_value,
    increment_by
FROM pg_sequences;
```

**Verificación de índices:**

```sql
-- Comparar índices entre origen y destino
SELECT 
    schemaname,
    tablename,
    indexname,
    indexdef
FROM pg_indexes 
WHERE schemaname = 'public'
ORDER BY tablename, indexname;
```

**Script de validación automatizada:**

```python
#!/usr/bin/env python3
import psycopg2
import sys
from datetime import datetime

def connect_db(host, port, database, username, password):
    """Establecer conexión a la base de datos"""
    try:
        conn = psycopg2.connect(
            host=host,
            port=port,
            database=database,
            user=username,
            password=password
        )
        return conn
    except Exception as e:
        print(f"Error conectando a {host}: {e}")
        return None

def compare_table_counts(source_conn, target_conn):
    """Comparar conteo de filas entre origen y destino"""
    query = """
    SELECT 
        schemaname,
        tablename,
        n_tup_ins - n_tup_del as row_count
    FROM pg_stat_user_tables 
    WHERE schemaname = 'public'
    ORDER BY tablename;
    """
    
    source_cur = source_conn.cursor()
    target_cur = target_conn.cursor()
    
    source_cur.execute(query)
    target_cur.execute(query)
    
    source_results = dict((row[1], row[2]) for row in source_cur.fetchall())
    target_results = dict((row[1], row[2]) for row in target_cur.fetchall())
    
    discrepancies = []
    for table, source_count in source_results.items():
        target_count = target_results.get(table, 0)
        if source_count != target_count:
            discrepancies.append({
                'table': table,
                'source_count': source_count,
                'target_count': target_count,
                'difference': source_count - target_count
            })
    
    return discrepancies

def main():
    # Configuración de conexiones
    heroku_config = {
        'host': 'heroku-host.compute-1.amazonaws.com',
        'port': 5432,
        'database': 'database_name',
        'username': 'heroku_user',
        'password': 'heroku_password'
    }
    
    rds_config = {
        'host': 'rds-instance.region.rds.amazonaws.com',
        'port': 5432,
        'database': 'database_name',
        'username': 'rds_user',
        'password': 'rds_password'
    }
    
    # Establecer conexiones
    source_conn = connect_db(**heroku_config)
    target_conn = connect_db(**rds_config)
    
    if not source_conn or not target_conn:
        sys.exit(1)
    
    print(f"Iniciando validación de migración - {datetime.now()}")
    
    # Comparar conteos de tablas
    discrepancies = compare_table_counts(source_conn, target_conn)
    
    if discrepancies:
        print("Discrepancias encontradas:")
        for disc in discrepancies:
            print(f"  Tabla: {disc['table']}")
            print(f"    Origen: {disc['source_count']} filas")
            print(f"    Destino: {disc['target_count']} filas")
            print(f"    Diferencia: {disc['difference']} filas")
    else:
        print("✅ Validación exitosa: Todos los conteos de tablas coinciden")
    
    source_conn.close()
    target_conn.close()

if __name__ == "__main__":
    main()
```

</TroubleshootingItem>

<TroubleshootingItem id="performance-optimization" summary="Optimización del rendimiento durante la migración">

**Configuración de parámetros para bases de datos grandes:**

```sql
-- Configurar parámetros en la base de datos de destino para mejorar rendimiento
ALTER SYSTEM SET shared_buffers = '4GB';
ALTER SYSTEM SET work_mem = '256MB';
ALTER SYSTEM SET maintenance_work_mem = '1GB';
ALTER SYSTEM SET checkpoint_completion_target = 0.9;
ALTER SYSTEM SET wal_buffers = '64MB';
ALTER SYSTEM SET effective_cache_size = '12GB';

-- Recargar configuración
SELECT pg_reload_conf();
```

**Estrategias de optimización DMS:**

```json
{
  "performance-settings": {
    "ParallelLoadThreads": 8,
    "ParallelLoadBufferSize": 50,
    "MaxFullLoadSubTasks": 8,
    "ParallelApplyThreads": 4,
    "ParallelApplyBufferSize": 100,
    "CommitRate": 10000
  }
}
```

**Monitoreo del progreso de migración:**

```bash
#!/bin/bash
# Script para monitorear progreso de DMS

aws dms describe-replication-tasks \
    --filters Name=replication-task-id,Values=heroku-to-rds-full-migration \
    --query 'ReplicationTasks[0].ReplicationTaskStats'

# Monitorear métricas CloudWatch
aws cloudwatch get-metric-statistics \
    --namespace AWS/DMS \
    --metric-name CDCLatencyTarget \
    --dimensions Name=ReplicationInstanceIdentifier,Value=heroku-to-rds-migration \
    --start-time 2024-12-19T00:00:00Z \
    --end-time 2024-12-19T23:59:59Z \
    --period 300 \
    --statistics Average
```

</TroubleshootingItem>

<TroubleshootingItem id="rollback-procedures" summary="Procedimientos de rollback y contingencia">

**Plan de rollback en caso de problemas:**

```bash
#!/bin/bash
# Script de rollback de emergencia

# 1. Detener la tarea de migración DMS
aws dms stop-replication-task \
    --replication-task-arn arn:aws:dms:region:account:task:heroku-to-rds-full-migration

# 2. Cambiar conexiones de aplicación de vuelta a Heroku
kubectl patch configmap app-config \
    --patch '{"data":{"DATABASE_URL":"postgres://heroku-user:password@heroku-host:5432/db"}}'

# 3. Reiniciar pods de aplicación
kubectl rollout restart deployment/app-deployment

# 4. Verificar conectividad
kubectl exec -it deployment/app-deployment -- psql $DATABASE_URL -c "SELECT version();"
```

**Verificaciones pre-rollback:**

```sql
-- Verificar que la aplicación puede conectar a Heroku
SELECT 
    pid,
    usename,
    application_name,
    client_addr,
    state
FROM pg_stat_activity 
WHERE datname = 'production_db';

-- Verificar integridad de datos en Heroku
SELECT 
    tablename,
    n_tup_ins - n_tup_del as current_rows
FROM pg_stat_user_tables 
WHERE schemaname = 'public'
ORDER BY current_rows DESC;
```

**Procedimiento de emergencia:**

1. **Notificación inmediata** al equipo de desarrollo
2. **Cambio de DNS** si es necesario para dirigir tráfico
3. **Monitoreo de métricas** de aplicación post-rollback
4. **Documentación de incidentes** para análisis posterior

</TroubleshootingItem>

<TroubleshootingItem id="post-migration-cleanup" summary="Limpieza y optimización post-migración">

**Tareas de limpieza después de migración exitosa:**

```sql
-- Actualizar estadísticas de la base de datos
ANALYZE;

-- Recompilar índices para optimizar rendimiento
REINDEX DATABASE database_name;

-- Verificar y limpiar logs de WAL antiguos
SELECT pg_current_wal_lsn();
SELECT pg_size_pretty(pg_wal_lsn_diff(pg_current_wal_lsn(), '0/0'));

-- Configurar autovacuum para nueva carga de trabajo
ALTER SYSTEM SET autovacuum_vacuum_scale_factor = 0.1;
ALTER SYSTEM SET autovacuum_analyze_scale_factor = 0.05;
SELECT pg_reload_conf();
```

**Limpieza de recursos AWS:**

```bash
#!/bin/bash
# Limpiar recursos DMS después de migración exitosa

# Eliminar tarea de replicación
aws dms delete-replication-task \
    --replication-task-arn arn:aws:dms:region:account:task:heroku-to-rds-full-migration

# Eliminar endpoints (después de confirmar que no se necesitan)
aws dms delete-endpoint --endpoint-arn arn:aws:dms:region:account:endpoint:heroku-postgres-source
aws dms delete-endpoint --endpoint-arn arn:aws:dms:region:account:endpoint:rds-postgres-target

# Eliminar instancia de replicación
aws dms delete-replication-instance \
    --replication-instance-arn arn:aws:dms:region:account:rep:heroku-to-rds-migration
```

**Configuración de monitoreo post-migración:**

```yaml
# CloudWatch alarms para monitorear la nueva base de datos
DatabaseCPUAlarm:
  Type: AWS::CloudWatch::Alarm
  Properties:
    AlarmName: RDS-HighCPU
    MetricName: CPUUtilization
    Namespace: AWS/RDS
    Statistic: Average
    Period: 300
    EvaluationPeriods: 2
    Threshold: 80

DatabaseConnectionsAlarm:
  Type: AWS::CloudWatch::Alarm
  Properties:
    AlarmName: RDS-HighConnections
    MetricName: DatabaseConnections
    Namespace: AWS/RDS
    Statistic: Average
    Period: 300
    EvaluationPeriods: 2
    Threshold: 40
```

</TroubleshootingItem>

---

_Esta sección de preguntas frecuentes fue generada automáticamente el 19 de diciembre de 2024 basada en una consulta real de usuario._
