---
sidebar_position: 3
title: "Error 502 y Registros de Pod No Cargan"
description: "Solución de problemas de errores 502 cuando no se pueden acceder a los registros de pods a través de la plataforma"
date: "2025-01-27"
category: "workload"
tags:
  ["error-502", "registros-pod", "solucion-de-problemas", "despliegue", "redes"]
---

import TroubleshootingItem from "@site/src/components/HomepageFeatures/troubleshootingitem";

# Error 502 y Registros de Pod No Cargan

**Fecha:** 27 de enero de 2025  
**Categoría:** Carga de trabajo  
**Etiquetas:** Error 502, Registros de Pod, Solución de problemas, Despliegue, Redes

## Descripción del Problema

**Contexto:** El usuario experimenta un error 502 al acceder a su aplicación desplegada en SleakOps, combinado con la imposibilidad de ver los registros de pod a través de la interfaz de la plataforma.

**Síntomas observados:**

- Error 502 Bad Gateway al acceder a la URL de la aplicación
- El botón de registros de pod en la interfaz de SleakOps no abre ni carga los registros
- El reenvío de puertos mediante Lens muestra pantalla en blanco con errores de red
- El contenedor Docker funciona correctamente al probarlo localmente
- El rollback a una compilación anterior funcional no resuelve el problema
- Los registros de otros proyectos y despliegues son accesibles

**Configuración relevante:**

- Entorno: Desarrollo
- Aplicación: Aplicación basada en monorepositorio
- Plataforma: Despliegue Kubernetes en SleakOps
- Pruebas locales: El contenedor Docker funciona correctamente
- Estado previo: La aplicación funcionaba con compilaciones anteriores

**Condiciones del error:**

- El error ocurre al acceder a la URL de la aplicación
- Los registros de pod son específicamente inaccesibles para este despliegue
- El reenvío de puertos falla con errores de red
- El problema persiste tras intentos de rollback
- El problema está aislado a pods/despliegue específicos

## Solución Detallada

<TroubleshootingItem id="initial-diagnosis" summary="Comprendiendo errores 502 con registros inaccesibles">

Cuando encuentras un error 502 combinado con registros de pod inaccesibles, esto típicamente indica:

1. **Problemas en el arranque del pod**: El pod puede estar fallando al iniciar correctamente o cayendo durante la inicialización
2. **Restricciones de recursos**: Memoria o CPU insuficientes causando terminación del pod
3. **Fallos en chequeos de salud**: Las sondas de readiness o liveness fallan
4. **Problemas de conectividad de red**: Problemas con la comunicación servicio-pod
5. **Problemas con el runtime del contenedor**: Problemas específicos del entorno Kubernetes frente a Docker local

El hecho de que los registros sean inaccesibles sugiere que los pods pueden estar en un ciclo de reinicio o en estado de fallo.

</TroubleshootingItem>

<TroubleshootingItem id="kubectl-diagnosis" summary="Uso de kubectl para inspección directa de pods">

Cuando la interfaz de SleakOps no puede mostrar registros, usa kubectl directamente:

```bash
# Obtener estado y eventos de pods
kubectl get pods -n <tu-namespace>
kubectl describe pod <nombre-pod> -n <tu-namespace>

# Obtener registros de pods caídos o reiniciándose
kubectl logs <nombre-pod> -n <tu-namespace> --previous

# Obtener registros en tiempo real
kubectl logs -f <nombre-pod> -n <tu-namespace>

# Revisar eventos del namespace
kubectl get events -n <tu-namespace> --sort-by='.lastTimestamp'
```

Busca:

- Cantidad de reinicios del pod
- Códigos de salida en la descripción del pod
- Eventos recientes mostrando errores
- Mensajes de límite de recursos excedido

</TroubleshootingItem>

<TroubleshootingItem id="resource-investigation" summary="Verificando restricciones de recursos">

Los problemas de recursos son comunes cuando Docker local funciona pero el despliegue en Kubernetes falla:

```bash
# Revisar uso de recursos
kubectl top pods -n <tu-namespace>

# Revisar límites de recursos en el despliegue
kubectl get deployment <nombre-despliegue> -n <tu-namespace> -o yaml | grep -A 10 resources

# Revisar recursos del nodo
kubectl describe nodes
```

**Soluciones comunes:**

1. **Incrementar límites de memoria**:

```yaml
resources:
  limits:
    memory: "1Gi" # Aumentar desde el valor por defecto
    cpu: "500m"
  requests:
    memory: "512Mi"
    cpu: "250m"
```

2. **Buscar fugas de memoria** en tu aplicación
3. **Optimizar el arranque del contenedor** para reducir picos de recursos

</TroubleshootingItem>

<TroubleshootingItem id="health-check-config" summary="Configurando correctamente los chequeos de salud">

Chequear salud incorrectamente puede causar errores 502:

```yaml
# Ejemplo de configuración correcta de chequeos de salud
livenessProbe:
  httpGet:
    path: /health
    port: 8080
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3

readinessProbe:
  httpGet:
    path: /ready
    port: 8080
  initialDelaySeconds: 5
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 3
```

**Consideraciones clave:**

- Asegurar que los endpoints de chequeo de salud existan en tu aplicación
- Configurar `initialDelaySeconds` adecuado para el tiempo de arranque de la app
- Usar endpoints diferentes para liveness y readiness si es posible
- Considerar deshabilitar temporalmente los chequeos para depuración

</TroubleshootingItem>

<TroubleshootingItem id="environment-differences" summary="Abordando diferencias entre entornos Docker y Kubernetes">

Cuando Docker funciona localmente pero Kubernetes falla, revisa:

**1. Variables de entorno:**

```bash
# Comparar variables de entorno
kubectl exec <nombre-pod> -n <tu-namespace> -- env
```

**2. Permisos en el sistema de archivos:**

- Kubernetes corre con contextos de usuario diferentes
- Verifica si tu app escribe en directorios específicos
- Asegura permisos adecuados en el Dockerfile

**3. Configuración de red:**

- La red en Kubernetes difiere de Docker
- Verifica que tu app se enlace a `0.0.0.0` y no a `localhost`
- Confirma que las configuraciones de puertos coinciden con las definiciones de servicio

**4. Dependencias y servicios externos:**

- Las conexiones a bases de datos pueden variar
- Endpoints de APIs externas podrían ser inaccesibles
- Diferencias en resolución DNS

</TroubleshootingItem>

<TroubleshootingItem id="sleakops-specific-debugging" summary="Pasos de depuración específicos para la plataforma SleakOps">

Para problemas específicos de SleakOps:

**1. Revisar registros de compilación:**

- Analiza el proceso de compilación en el panel de SleakOps
- Busca advertencias o errores durante la creación de la imagen
- Verifica que todos los pasos de compilación se completaron exitosamente

**2. Configuración del despliegue:**

- Verifica si la configuración del despliegue cambió
- Confirma que las variables de entorno estén correctamente definidas
- Asegura que secretos y configmaps sean accesibles

**3. Configuración del servicio:**

- Verifica que el servicio enrute correctamente a los pods
- Revisa configuración de ingress si aplica
- Asegura que el balanceador de carga esté saludable

**4. Recursos de la plataforma:**

- Comprueba que el clúster tenga recursos suficientes
- Verifica que no haya problemas a nivel plataforma
- Contacta soporte de SleakOps si la interfaz de la plataforma no responde

</TroubleshootingItem>

<TroubleshootingItem id="emergency-recovery" summary="Pasos de recuperación de emergencia">

Si el problema es urgente y requiere resolución inmediata:

**1. Forzar reinicio del pod:**

```bash
kubectl delete pod <nombre-pod> -n <tu-namespace>
```

**2. Escalar hacia abajo y luego hacia arriba:**

```bash
kubectl scale deployment <nombre-despliegue> --replicas=0 -n <tu-namespace>
kubectl scale deployment <nombre-despliegue> --replicas=1 -n <tu-namespace>
```

**3. Incremento temporal de recursos:**

- Aumentar temporalmente límites de recursos
- Reducir escala de otros servicios no críticos
- Usar nodos con más recursos si están disponibles

**4. Rollback a imagen conocida como funcional:**

```bash
# Rollback usando kubectl
kubectl rollout undo deployment/<nombre-despliegue> -n <tu-namespace>

# Verificar estado del rollback
kubectl rollout status deployment/<nombre-despliegue> -n <tu-namespace>
```

**5. Despliegue de emergencia con configuración mínima:**

```yaml
# deployment-emergency.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: emergency-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: emergency-app
  template:
    metadata:
      labels:
        app: emergency-app
    spec:
      containers:
      - name: app
        image: <imagen-funcional-anterior>
        ports:
        - containerPort: 8080
        resources:
          limits:
            memory: "2Gi"
            cpu: "1000m"
          requests:
            memory: "1Gi"
            cpu: "500m"
        # Deshabilitar chequeos de salud temporalmente
        # livenessProbe: {}
        # readinessProbe: {}
```

</TroubleshootingItem>

<TroubleshootingItem id="prevention-strategies" summary="Estrategias de prevención para futuros despliegues">

**1. Implementar chequeos de salud robustos:**

```javascript
// Ejemplo para aplicación Node.js
const express = require('express');
const app = express();

// Endpoint de health check básico
app.get('/health', (req, res) => {
  res.status(200).json({ status: 'healthy', timestamp: new Date().toISOString() });
});

// Endpoint de readiness más complejo
app.get('/ready', async (req, res) => {
  try {
    // Verificar conexiones a base de datos
    await checkDatabaseConnection();
    
    // Verificar servicios externos críticos
    await checkExternalServices();
    
    res.status(200).json({ 
      status: 'ready', 
      timestamp: new Date().toISOString(),
      checks: {
        database: 'ok',
        external_services: 'ok'
      }
    });
  } catch (error) {
    res.status(503).json({ 
      status: 'not ready', 
      error: error.message,
      timestamp: new Date().toISOString()
    });
  }
});
```

**2. Configurar monitoreo proactivo:**

```yaml
# Configuración de alertas
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: app-alerts
spec:
  groups:
  - name: app.rules
    rules:
    - alert: PodCrashLooping
      expr: rate(kube_pod_container_status_restarts_total[15m]) > 0
      for: 5m
      labels:
        severity: critical
      annotations:
        summary: "Pod {{ $labels.pod }} is crash looping"
        
    - alert: HighMemoryUsage
      expr: container_memory_usage_bytes / container_spec_memory_limit_bytes > 0.9
      for: 2m
      labels:
        severity: warning
      annotations:
        summary: "High memory usage on {{ $labels.pod }}"
```

**3. Implementar despliegues graduales:**

```yaml
# Estrategia de rolling update conservadora
spec:
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 0
      maxSurge: 1
  minReadySeconds: 30
  progressDeadlineSeconds: 600
```

**4. Usar staging que replique producción:**

- Configurar entorno de staging con recursos similares a producción
- Probar con volúmenes de datos realistas
- Validar chequeos de salud en staging antes de producción
- Implementar pruebas de carga automatizadas

</TroubleshootingItem>

<TroubleshootingItem id="advanced-debugging" summary="Técnicas avanzadas de depuración">

**1. Depuración con contenedores sidecar:**

```yaml
# Agregar contenedor de depuración
spec:
  containers:
  - name: app
    image: tu-app:latest
  - name: debug
    image: busybox
    command: ['sleep', '3600']
    volumeMounts:
    - name: shared-logs
      mountPath: /logs
```

**2. Usar herramientas de profiling:**

```bash
# Instalar herramientas de depuración en el pod
kubectl exec -it <pod-name> -- /bin/bash

# Dentro del pod
apt-get update && apt-get install -y htop strace tcpdump

# Monitorear procesos
htop

# Rastrear llamadas del sistema
strace -p <pid>

# Capturar tráfico de red
tcpdump -i any port 8080
```

**3. Análisis de dumps de memoria:**

```bash
# Para aplicaciones Java
kubectl exec <pod-name> -- jstack <pid>
kubectl exec <pod-name> -- jmap -dump:format=b,file=/tmp/heap.hprof <pid>

# Para aplicaciones Node.js
kubectl exec <pod-name> -- kill -USR2 <pid>  # Genera heap dump
```

**4. Depuración de red:**

```bash
# Verificar conectividad desde el pod
kubectl exec <pod-name> -- nslookup <service-name>
kubectl exec <pod-name> -- curl -v http://<service-name>:<port>/health

# Verificar configuración de iptables
kubectl exec <pod-name> -- iptables -L

# Verificar rutas de red
kubectl exec <pod-name> -- route -n
```

</TroubleshootingItem>

<TroubleshootingItem id="documentation-and-runbooks" summary="Documentación y runbooks para el equipo">

**1. Crear runbook de respuesta a incidentes:**

```markdown
# Runbook: Error 502 con Logs Inaccesibles

## Pasos inmediatos (5 minutos)
1. Verificar estado de pods: `kubectl get pods -n <namespace>`
2. Revisar eventos recientes: `kubectl get events --sort-by='.lastTimestamp'`
3. Intentar acceso a logs: `kubectl logs <pod> --previous`

## Investigación (15 minutos)
1. Verificar recursos: `kubectl top pods`
2. Revisar chequeos de salud
3. Comparar con configuración funcional anterior

## Escalación
- Si no se resuelve en 20 minutos, contactar al equipo de plataforma
- Si es crítico para producción, implementar rollback inmediato
```

**2. Configurar dashboards de monitoreo:**

```yaml
# Dashboard de Grafana para monitoreo de aplicación
{
  "dashboard": {
    "title": "Application Health Dashboard",
    "panels": [
      {
        "title": "Pod Status",
        "type": "stat",
        "targets": [
          {
            "expr": "kube_pod_status_phase{namespace=\"your-namespace\"}"
          }
        ]
      },
      {
        "title": "Memory Usage",
        "type": "graph",
        "targets": [
          {
            "expr": "container_memory_usage_bytes{namespace=\"your-namespace\"}"
          }
        ]
      },
      {
        "title": "HTTP Response Codes",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(http_requests_total[5m])"
          }
        ]
      }
    ]
  }
}
```

**3. Automatizar chequeos de salud:**

```bash
#!/bin/bash
# health-check-script.sh

NAMESPACE="your-namespace"
DEPLOYMENT="your-deployment"

echo "Verificando salud del despliegue $DEPLOYMENT en namespace $NAMESPACE"

# Verificar estado de pods
PODS=$(kubectl get pods -n $NAMESPACE -l app=$DEPLOYMENT --no-headers)
echo "Estado de pods:"
echo "$PODS"

# Verificar si hay pods en estado no saludable
UNHEALTHY=$(echo "$PODS" | grep -v "Running\|Completed" | wc -l)

if [ $UNHEALTHY -gt 0 ]; then
    echo "ALERTA: $UNHEALTHY pods no están en estado saludable"
    
    # Obtener logs de pods problemáticos
    kubectl get pods -n $NAMESPACE -l app=$DEPLOYMENT --no-headers | \
    grep -v "Running\|Completed" | \
    awk '{print $1}' | \
    while read pod; do
        echo "Logs del pod $pod:"
        kubectl logs $pod -n $NAMESPACE --tail=50
    done
    
    exit 1
else
    echo "Todos los pods están saludables"
    exit 0
fi
```

</TroubleshootingItem>

---

_Esta sección de preguntas frecuentes fue generada automáticamente el 27 de enero de 2025 basada en una consulta real de usuario._
