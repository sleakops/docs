---
sidebar_position: 3
title: "Tiempo de Espera en el Despliegue Durante Migraciones de Base de Datos"
description: "Solución para fallos en el despliegue causados por tiempos de espera en migraciones de base de datos en tareas previas al despliegue"
date: "2024-04-25"
category: "proyecto"
tags:
  [
    "despliegue",
    "base de datos",
    "migraciones",
    "tiempo de espera",
    "pre-despliegue",
  ]
---

import TroubleshootingItem from "@site/src/components/HomepageFeatures/troubleshootingitem";

# Tiempo de Espera en el Despliegue Durante Migraciones de Base de Datos

**Fecha:** 25 de abril de 2024  
**Categoría:** Proyecto  
**Etiquetas:** Despliegue, Base de Datos, Migraciones, Tiempo de Espera, Pre-despliegue

## Descripción del Problema

**Contexto:** El despliegue del servicio backend falla durante la fase previa al despliegue al ejecutar migraciones de base de datos, causando que todo el proceso de despliegue termine por tiempo de espera y falle.

**Síntomas Observados:**

- El despliegue falla durante la ejecución de la tarea previa al despliegue
- Las migraciones de base de datos tardan demasiado en completarse
- El proceso termina por límites de tiempo de espera
- Múltiples intentos de despliegue muestran comportamiento similar de tiempo de espera
- Pueden aparecer errores secundarios en la aplicación (ImportError) tras fallos por tiempo de espera

**Configuración Relevante:**

- Tipo de servicio: Aplicación backend
- Tarea previa al despliegue: Migraciones de base de datos
- Infraestructura: Nodos gestionados por Karpenter (no se detectaron problemas de aprovisionamiento)
- Base de datos: Base de datos de producción con posibles grandes volúmenes de datos

**Condiciones de Error:**

- El error ocurre durante la fase previa al despliegue
- Las migraciones exceden los límites de tiempo configurados
- El problema aparece consistentemente en los intentos de despliegue
- Puede ir seguido de errores de importación en la aplicación en intentos posteriores

## Solución Detallada

<TroubleshootingItem id="timeout-diagnosis" summary="Diagnóstico de problemas de tiempo de espera en migraciones">

Los tiempos de espera en migraciones de base de datos suelen ocurrir debido a:

1. **Migraciones de grandes volúmenes de datos**: Operaciones en tablas con millones de registros
2. **Cambios en el esquema**: Añadir índices o columnas a tablas grandes
3. **Contención de bloqueos**: Migraciones que entran en conflicto con conexiones activas a la base de datos
4. **Restricciones de recursos**: CPU/memoria insuficiente en la base de datos durante la migración
5. **Latencia de red**: Conexión lenta entre la aplicación y la base de datos

Para diagnosticar la causa específica:

```bash
# Revisar los logs de migración
kubectl logs -f deployment/your-backend-service -c pre-deploy

# Monitorizar el rendimiento de la base de datos durante la migración
# (Ejemplo AWS RDS)
aws rds describe-db-instances --db-instance-identifier your-db
```

</TroubleshootingItem>

<TroubleshootingItem id="increase-timeout" summary="Incrementar los límites de tiempo de espera en pre-despliegue">

En SleakOps, puedes configurar límites de tiempo de espera más largos para las tareas previas al despliegue:

1. Ve a tus **Configuraciones del Proyecto**
2. Navega a **Configuración de Despliegue**
3. Busca **Configuración de Tareas Previas al Despliegue**
4. Incrementa el valor de **Timeout**:

```yaml
# ejemplo sleakops.yaml
services:
  backend:
    pre_deploy:
      timeout: 1800 # 30 minutos en lugar de los 10 minutos por defecto
      command: "python manage.py migrate"
```

Valores recomendados para timeout:

- Aplicaciones pequeñas: 600 segundos (10 minutos)
- Aplicaciones medianas: 1200 segundos (20 minutos)
- Aplicaciones grandes: 1800+ segundos (30+ minutos)

</TroubleshootingItem>

<TroubleshootingItem id="migration-optimization" summary="Optimizar migraciones de base de datos">

Para hacer las migraciones más rápidas y confiables:

**1. Dividir migraciones grandes:**

```python
# En lugar de una migración grande
class Migration(migrations.Migration):
    operations = [
        # 50 operaciones aquí
    ]

# Dividir en migraciones más pequeñas
class Migration001(migrations.Migration):
    operations = [
        # 10 operaciones aquí
    ]

class Migration002(migrations.Migration):
    operations = [
        # 10 operaciones más aquí
    ]
```

**2. Usar optimizaciones específicas de la base de datos:**

```python
# Ejemplo PostgreSQL - añadir índices concurrentemente
from django.contrib.postgres.operations import AddIndexConcurrently

class Migration(migrations.Migration):
    atomic = False  # Requerido para operaciones concurrentes
    operations = [
        AddIndexConcurrently(
            model_name='yourmodel',
            index=models.Index(fields=['field_name'], name='idx_field_name'),
        ),
    ]
```

**3. Ejecutar migraciones pesadas fuera de línea:**

```bash
# Para migraciones muy grandes, ejecútalas manualmente durante ventanas de mantenimiento
kubectl exec -it deployment/backend-service -- python manage.py migrate --plan
kubectl exec -it deployment/backend-service -- python manage.py migrate app_name migration_number
```

</TroubleshootingItem>

<TroubleshootingItem id="alternative-strategies" summary="Estrategias alternativas de despliegue">

Si los tiempos de espera persisten, considera estas estrategias de despliegue:

**1. Despliegue Blue-Green con migración manual:**

```yaml
# sleakops.yaml
services:
  backend:
    deployment_strategy: blue_green
    pre_deploy:
      enabled: false # Deshabilitar migraciones automáticas
    health_check:
      path: /health
      timeout: 30
```

Luego ejecuta las migraciones manualmente:

```bash
# Después de que el entorno azul esté listo
kubectl exec -it deployment/backend-service-blue -- python manage.py migrate
# Cambiar el tráfico después de completar la migración
```

**2. Despliegue Rolling con trabajos de migración:**

```yaml
# Crear un job separado para migraciones
apiVersion: batch/v1
kind: Job
metadata:
  name: db-migration-job
spec:
  template:
    spec:
      containers:
        - name: migrate
          image: your-backend-image
          command: ["python", "manage.py", "migrate"]
      restartPolicy: Never
  backoffLimit: 3
```

**3. Pooling de conexiones a la base de datos:**

```python
# settings.py - Optimizar conexiones a base de datos
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'CONN_MAX_AGE': 600,  # Pooling de conexiones
        'OPTIONS': {
            'MAX_CONNS': 20,
            'MIN_CONNS': 5,
        }
    }
}
```

</TroubleshootingItem>

<TroubleshootingItem id="monitoring-prevention" summary="Monitoreo y prevención">

Para prevenir futuros problemas de tiempo de espera:

**1. Monitorizar el rendimiento de las migraciones:**

```bash
# Añadir logging a las migraciones
import logging
logger = logging.getLogger(__name__)

class Migration(migrations.Migration):
    def apply_migration(self, project_state, schema_editor, collect_sql=False):
        logger.info(f"Iniciando migración {self.name}")
        start_time = time.time()
        result = super().apply_migration(project_state, schema_editor, collect_sql)
        duration = time.time() - start_time
        logger.info(f"Migración {self.name} completada en {duration:.2f} segundos")
        return result
```

**2. Configurar alertas:**

```yaml
# Alerta cuando las migraciones tardan demasiado
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: migration-alerts
spec:
  groups:
    - name: migrations
      rules:
        - alert: MigrationTimeout
          expr: increase(django_migration_duration_seconds[5m]) > 300
          labels:
            severity: warning
          annotations:
            summary: "Migración de base de datos tardando demasiado"
```

**3. Probar migraciones en staging:**

```bash
# Siempre probar con volúmenes de datos similares a producción
# Usar snapshots de base de datos para pruebas realistas
```
