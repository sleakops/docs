---
sidebar_position: 15
title: "Error 502 Bad Gateway con Aplicación NestJS"
description: "Solución para errores 502 Bad Gateway cuando los pods de NestJS están en ejecución pero los endpoints API no son accesibles"
date: "2025-01-15"
category: "workload"
tags: ["502", "bad-gateway", "nestjs", "api", "troubleshooting"]
---

import TroubleshootingItem from "@site/src/components/HomepageFeatures/troubleshootingitem";

# Error 502 Bad Gateway con Aplicación NestJS

**Fecha:** 15 de enero de 2025  
**Categoría:** Carga de trabajo  
**Etiquetas:** 502, Bad Gateway, NestJS, API, Solución de problemas

## Descripción del Problema

**Contexto:** El usuario tiene una aplicación NestJS desplegada en Kubernetes que muestra logs normales de inicio y parece estar ejecutándose correctamente, pero los endpoints API devuelven errores 502 Bad Gateway.

**Síntomas observados:**

- Los pods están en ejecución y muestran logs normales de inicio de NestJS
- Los módulos de la aplicación se inicializan correctamente (TypeORM, Config, Logger, etc.)
- Las rutas están mapeadas correctamente (`/health`, `/session`)
- Las solicitudes API devuelven error `502 Bad Gateway`
- Fallan tanto las solicitudes GET como POST

**Configuración relevante:**

- Aplicación: NestJS con TypeORM
- Nombre del servicio: `rattlesnake-develop`
- Número de pods: 2 pods en ejecución
- Rutas: `/health` (GET), `/session` (POST)

**Condiciones del error:**

- El error ocurre tras un inicio exitoso de la aplicación
- Afecta a todos los endpoints API
- Sucede a pesar de que los pods aparecen como saludables en Kubernetes
- El problema se resuelve generando un nuevo despliegue

## Solución detallada

<TroubleshootingItem id="initial-diagnosis" summary="Comprendiendo el error 502 Bad Gateway en Kubernetes">

Un error 502 Bad Gateway en Kubernetes típicamente indica que el controlador de ingreso o el servicio puede alcanzar el pod, pero el pod no responde correctamente a las solicitudes HTTP. Las causas comunes incluyen:

1. **Desajuste de puerto**: La aplicación escucha en un puerto diferente al que espera el servicio
2. **Fallos en las comprobaciones de salud**: Las sondas de readiness/liveness fallan
3. **Aplicación no completamente lista**: La app parece iniciada pero el servidor HTTP no está escuchando
4. **Problemas con el selector del servicio**: El servicio no enruta a los pods correctos

</TroubleshootingItem>

<TroubleshootingItem id="port-verification" summary="Verificar la configuración del puerto de la aplicación">

Verifica si tu aplicación NestJS está escuchando en el puerto correcto:

```typescript
// En tu archivo main.ts
import { NestFactory } from "@nestjs/core";
import { AppModule } from "./app.module";

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  const port = process.env.PORT || 3000;
  await app.listen(port, "0.0.0.0"); // Importante: enlazar a 0.0.0.0
  console.log(`La aplicación está ejecutándose en: ${await app.getUrl()}`);
}
bootstrap();
```

Asegúrate de que el servicio de Kubernetes coincida con este puerto:

```yaml
apiVersion: v1
kind: Service
metadata:
  name: rattlesnake-develop
spec:
  selector:
    app: rattlesnake-develop
  ports:
    - port: 80
      targetPort: 3000 # Debe coincidir con el puerto de tu app
      protocol: TCP
```

</TroubleshootingItem>

<TroubleshootingItem id="health-checks" summary="Configurar comprobaciones de salud adecuadas">

Agrega endpoints de comprobación de salud y configura las sondas de Kubernetes:

```typescript
// Añadir a tu controlador de la app
@Get('/health')
getHealth() {
  return {
    status: 'ok',
    timestamp: new Date().toISOString(),
    uptime: process.uptime()
  };
}

@Get('/ready')
getReadiness() {
  // Añade cualquier chequeo de readiness (conexión a base de datos, etc.)
  return { status: 'ready' };
}
```

Configura las sondas en Kubernetes:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: rattlesnake-develop
spec:
  template:
    spec:
      containers:
        - name: app
          image: your-image
          ports:
            - containerPort: 3000
          livenessProbe:
            httpGet:
              path: /health
              port: 3000
            initialDelaySeconds: 30
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /ready
              port: 3000
            initialDelaySeconds: 5
            periodSeconds: 5
```

</TroubleshootingItem>

<TroubleshootingItem id="service-debugging" summary="Depurar servicio y conectividad de endpoints">

Usa estos comandos para depurar la conexión:

```bash
# Verificar si los pods están listos
kubectl get pods -l app=rattlesnake-develop

# Verificar endpoints del servicio
kubectl get endpoints rattlesnake-develop

# Probar conectividad directa al pod
kubectl port-forward pod/rattlesnake-develop-xxx 3000:3000
# Luego probar: curl http://localhost:3000/health

# Verificar conectividad al servicio
kubectl port-forward service/rattlesnake-develop 8080:80
# Luego probar: curl http://localhost:8080/health

# Revisar logs del pod para arranque del servidor HTTP
kubectl logs -f deployment/rattlesnake-develop
```

</TroubleshootingItem>

<TroubleshootingItem id="nestjs-specific-fixes" summary="Correcciones específicas de configuración para NestJS">

Asegúrate de que tu aplicación NestJS esté configurada correctamente para entornos contenerizados:

```typescript
// Habilitar apagado ordenado\async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // Habilitar hooks para apagado
  app.enableShutdownHooks();

  // Configurar CORS si es necesario
  app.enableCors();

  // Prefijo global (opcional)
  app.setGlobalPrefix('api');

  // Enlazar a todas las interfaces
  await app.listen(process.env.PORT || 3000, '0.0.0.0');
}
```

Verifica la configuración de tu base de datos para entornos contenerizados:

```typescript
// Configuración de TypeORM
@Module({
  imports: [
    TypeOrmModule.forRootAsync({
      useFactory: () => ({
        type: "postgres",
        host: process.env.DB_HOST,
        port: parseInt(process.env.DB_PORT) || 5432,
        username: process.env.DB_USERNAME,
        password: process.env.DB_PASSWORD,
        database: process.env.DB_NAME,
        synchronize: false, // Nunca true en producción
        retryAttempts: 3,
        retryDelay: 3000,
      }),
    }),
  ],
})
export class AppModule {}
```

</TroubleshootingItem>

<TroubleshootingItem id="deployment-solution" summary="Forzar nuevo despliegue (solución inmediata)">

Si necesitas una solución inmediata
