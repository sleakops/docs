---
sidebar_position: 15
title: "Error 502 Bad Gateway con Aplicación NestJS"
description: "Solución para errores 502 Bad Gateway cuando los pods de NestJS están en ejecución pero los endpoints API no son accesibles"
date: "2025-01-15"
category: "workload"
tags: ["502", "bad-gateway", "nestjs", "api", "troubleshooting"]
---

import TroubleshootingItem from "@site/src/components/HomepageFeatures/troubleshootingitem";

# Error 502 Bad Gateway con Aplicación NestJS

**Fecha:** 15 de enero de 2025  
**Categoría:** Carga de trabajo  
**Etiquetas:** 502, Bad Gateway, NestJS, API, Solución de problemas

## Descripción del Problema

**Contexto:** El usuario tiene una aplicación NestJS desplegada en Kubernetes que muestra logs normales de inicio y parece estar ejecutándose correctamente, pero los endpoints API devuelven errores 502 Bad Gateway.

**Síntomas observados:**

- Los pods están en ejecución y muestran logs normales de inicio de NestJS
- Los módulos de la aplicación se inicializan correctamente (TypeORM, Config, Logger, etc.)
- Las rutas están mapeadas correctamente (`/health`, `/session`)
- Las solicitudes API devuelven error `502 Bad Gateway`
- Fallan tanto las solicitudes GET como POST

**Configuración relevante:**

- Aplicación: NestJS con TypeORM
- Nombre del servicio: `rattlesnake-develop`
- Número de pods: 2 pods en ejecución
- Rutas: `/health` (GET), `/session` (POST)

**Condiciones del error:**

- El error ocurre tras un inicio exitoso de la aplicación
- Afecta a todos los endpoints API
- Sucede a pesar de que los pods aparecen como saludables en Kubernetes
- El problema se resuelve generando un nuevo despliegue

## Solución detallada

<TroubleshootingItem id="initial-diagnosis" summary="Comprendiendo el error 502 Bad Gateway en Kubernetes">

Un error 502 Bad Gateway en Kubernetes típicamente indica que el controlador de ingreso o el servicio puede alcanzar el pod, pero el pod no responde correctamente a las solicitudes HTTP. Las causas comunes incluyen:

1. **Desajuste de puerto**: La aplicación escucha en un puerto diferente al que espera el servicio
2. **Fallos en las comprobaciones de salud**: Las sondas de readiness/liveness fallan
3. **Aplicación no completamente lista**: La app parece iniciada pero el servidor HTTP no está escuchando
4. **Problemas con el selector del servicio**: El servicio no enruta a los pods correctos

</TroubleshootingItem>

<TroubleshootingItem id="port-verification" summary="Verificar la configuración del puerto de la aplicación">

Verifica si tu aplicación NestJS está escuchando en el puerto correcto:

```typescript
// En tu archivo main.ts
import { NestFactory } from "@nestjs/core";
import { AppModule } from "./app.module";

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  const port = process.env.PORT || 3000;
  await app.listen(port, "0.0.0.0"); // Importante: enlazar a 0.0.0.0
  console.log(`La aplicación está ejecutándose en: ${await app.getUrl()}`);
}
bootstrap();
```

Asegúrate de que el servicio de Kubernetes coincida con este puerto:

```yaml
apiVersion: v1
kind: Service
metadata:
  name: rattlesnake-develop
spec:
  selector:
    app: rattlesnake-develop
  ports:
    - port: 80
      targetPort: 3000 # Debe coincidir con el puerto de tu app
      protocol: TCP
```

</TroubleshootingItem>

<TroubleshootingItem id="health-checks" summary="Configurar comprobaciones de salud adecuadas">

Agrega endpoints de comprobación de salud y configura las sondas de Kubernetes:

```typescript
// Añadir a tu controlador de la app
@Get('/health')
getHealth() {
  return {
    status: 'ok',
    timestamp: new Date().toISOString(),
    uptime: process.uptime()
  };
}

@Get('/ready')
getReadiness() {
  // Añade cualquier chequeo de readiness (conexión a base de datos, etc.)
  return { status: 'ready' };
}
```

Configura las sondas en Kubernetes:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: rattlesnake-develop
spec:
  template:
    spec:
      containers:
        - name: app
          image: your-image
          ports:
            - containerPort: 3000
          livenessProbe:
            httpGet:
              path: /health
              port: 3000
            initialDelaySeconds: 30
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /ready
              port: 3000
            initialDelaySeconds: 5
            periodSeconds: 5
```

</TroubleshootingItem>

<TroubleshootingItem id="service-debugging" summary="Depurar servicio y conectividad de endpoints">

Usa estos comandos para depurar la conexión:

```bash
# Verificar si los pods están listos
kubectl get pods -l app=rattlesnake-develop

# Verificar endpoints del servicio
kubectl get endpoints rattlesnake-develop

# Probar conectividad directa al pod
kubectl port-forward pod/rattlesnake-develop-xxx 3000:3000
# Luego probar: curl http://localhost:3000/health

# Verificar conectividad al servicio
kubectl port-forward service/rattlesnake-develop 8080:80
# Luego probar: curl http://localhost:8080/health

# Revisar logs del pod para arranque del servidor HTTP
kubectl logs -f deployment/rattlesnake-develop
```

</TroubleshootingItem>

<TroubleshootingItem id="nestjs-specific-fixes" summary="Correcciones específicas de configuración para NestJS">

Asegúrate de que tu aplicación NestJS esté configurada correctamente para entornos contenerizados:

```typescript
// Habilitar apagado ordenado\async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // Habilitar hooks para apagado
  app.enableShutdownHooks();

  // Configurar CORS si es necesario
  app.enableCors();

  // Prefijo global (opcional)
  app.setGlobalPrefix('api');

  // Enlazar a todas las interfaces
  await app.listen(process.env.PORT || 3000, '0.0.0.0');
}
```

Verifica la configuración de tu base de datos para entornos contenerizados:

```typescript
// Configuración de TypeORM
@Module({
  imports: [
    TypeOrmModule.forRootAsync({
      useFactory: () => ({
        type: "postgres",
        host: process.env.DB_HOST,
        port: parseInt(process.env.DB_PORT) || 5432,
        username: process.env.DB_USERNAME,
        password: process.env.DB_PASSWORD,
        database: process.env.DB_NAME,
        synchronize: false, // Nunca true en producción
        retryAttempts: 3,
        retryDelay: 3000,
      }),
    }),
  ],
})
export class AppModule {}
```

</TroubleshootingItem>

<TroubleshootingItem id="deployment-solution" summary="Forzar nuevo despliegue (solución inmediata)">

Si necesitas una solución inmediata, puedes forzar un nuevo despliegue:

```bash
# Opción 1: Reiniciar el despliegue
kubectl rollout restart deployment/rattlesnake-develop

# Opción 2: Escalar a 0 y luego de vuelta
kubectl scale deployment rattlesnake-develop --replicas=0
kubectl scale deployment rattlesnake-develop --replicas=2

# Opción 3: Eliminar pods para forzar recreación
kubectl delete pods -l app=rattlesnake-develop
```

Sin embargo, es importante identificar la causa raíz para evitar que el problema se repita.

</TroubleshootingItem>

<TroubleshootingItem id="ingress-configuration" summary="Verificar configuración del Ingress">

Revisa la configuración del Ingress para asegurar que esté enrutando correctamente:

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: rattlesnake-develop-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/proxy-connect-timeout: "30"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "30"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "30"
spec:
  rules:
    - host: your-domain.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: rattlesnake-develop
                port:
                  number: 80
```

Verifica el estado del Ingress:

```bash
# Verificar configuración del Ingress
kubectl describe ingress rattlesnake-develop-ingress

# Verificar logs del controlador de Ingress
kubectl logs -n ingress-nginx deployment/ingress-nginx-controller

# Probar conectividad desde el controlador de Ingress
kubectl exec -n ingress-nginx deployment/ingress-nginx-controller -- curl -I http://rattlesnake-develop.default.svc.cluster.local/health
```

</TroubleshootingItem>

<TroubleshootingItem id="environment-variables" summary="Verificar variables de entorno y configuración">

Asegúrate de que todas las variables de entorno necesarias estén configuradas:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: rattlesnake-develop
spec:
  template:
    spec:
      containers:
        - name: app
          image: your-nestjs-app:latest
          env:
            - name: NODE_ENV
              value: "production"
            - name: PORT
              value: "3000"
            - name: DB_HOST
              value: "your-db-host"
            - name: DB_PORT
              value: "5432"
            - name: DB_USERNAME
              valueFrom:
                secretKeyRef:
                  name: db-secret
                  key: username
            - name: DB_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: db-secret
                  key: password
            - name: DB_NAME
              value: "your-database"
```

Verifica que las variables estén disponibles en el pod:

```bash
# Verificar variables de entorno en el pod
kubectl exec -it deployment/rattlesnake-develop -- env | grep -E "(PORT|DB_|NODE_ENV)"

# Verificar conectividad a la base de datos
kubectl exec -it deployment/rattlesnake-develop -- nc -zv your-db-host 5432
```

</TroubleshootingItem>

<TroubleshootingItem id="logging-monitoring" summary="Configurar logging y monitoreo avanzado">

Implementa logging detallado para diagnosticar problemas futuros:

```typescript
// Configurar logger personalizado
import { Logger } from '@nestjs/common';

@Injectable()
export class AppService {
  private readonly logger = new Logger(AppService.name);

  onModuleInit() {
    this.logger.log('AppService initialized');
    this.logger.log(`Server starting on port ${process.env.PORT || 3000}`);
  }

  @Get('/health')
  getHealth() {
    this.logger.log('Health check requested');
    return {
      status: 'ok',
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      memory: process.memoryUsage(),
      env: process.env.NODE_ENV
    };
  }
}
```

Configurar middleware de logging para requests:

```typescript
// Middleware de logging
import { Injectable, NestMiddleware, Logger } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';

@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  private logger = new Logger('HTTP');

  use(req: Request, res: Response, next: NextFunction): void {
    const { ip, method, originalUrl } = req;
    const userAgent = req.get('User-Agent') || '';

    res.on('close', () => {
      const { statusCode } = res;
      const contentLength = res.get('Content-Length');

      this.logger.log(
        `${method} ${originalUrl} ${statusCode} ${contentLength} - ${userAgent} ${ip}`
      );
    });

    next();
  }
}
```

</TroubleshootingItem>

<TroubleshootingItem id="performance-optimization" summary="Optimización de rendimiento y recursos">

Configura recursos apropiados para evitar problemas de rendimiento:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: rattlesnake-develop
spec:
  template:
    spec:
      containers:
        - name: app
          image: your-nestjs-app:latest
          resources:
            requests:
              memory: "256Mi"
              cpu: "250m"
            limits:
              memory: "512Mi"
              cpu: "500m"
          # Configurar startup probe para apps que tardan en iniciar
          startupProbe:
            httpGet:
              path: /health
              port: 3000
            failureThreshold: 30
            periodSeconds: 10
```

Optimizar la aplicación NestJS:

```typescript
// Configurar timeouts y límites
async function bootstrap() {
  const app = await NestFactory.create(AppModule, {
    logger: ['error', 'warn', 'log'],
  });

  // Configurar timeouts
  app.use((req, res, next) => {
    res.setTimeout(30000, () => {
      res.status(408).send('Request Timeout');
    });
    next();
  });

  // Configurar límites de payload
  app.use(express.json({ limit: '10mb' }));
  app.use(express.urlencoded({ extended: true, limit: '10mb' }));

  await app.listen(process.env.PORT || 3000, '0.0.0.0');
}
```

</TroubleshootingItem>

<TroubleshootingItem id="database-connection-troubleshooting" summary="Solución de problemas de conexión a base de datos">

Diagnosticar y resolver problemas de conexión a la base de datos:

```typescript
// Configuración robusta de TypeORM
@Module({
  imports: [
    TypeOrmModule.forRootAsync({
      useFactory: () => ({
        type: 'postgres',
        host: process.env.DB_HOST,
        port: parseInt(process.env.DB_PORT) || 5432,
        username: process.env.DB_USERNAME,
        password: process.env.DB_PASSWORD,
        database: process.env.DB_NAME,
        synchronize: false,
        logging: process.env.NODE_ENV === 'development',
        retryAttempts: 5,
        retryDelay: 3000,
        autoLoadEntities: true,
        keepConnectionAlive: true,
        extra: {
          connectionLimit: 10,
          acquireTimeout: 60000,
          timeout: 60000,
        },
      }),
    }),
  ],
})
export class DatabaseModule {}
```

Implementar health check para la base de datos:

```typescript
@Injectable()
export class HealthService {
  constructor(
    @InjectConnection() private connection: Connection,
  ) {}

  @Get('/health/db')
  async checkDatabase() {
    try {
      await this.connection.query('SELECT 1');
      return { status: 'ok', database: 'connected' };
    } catch (error) {
      throw new ServiceUnavailableException('Database connection failed');
    }
  }
}
```

</TroubleshootingItem>

<TroubleshootingItem id="security-configuration" summary="Configuración de seguridad y CORS">

Configurar seguridad apropiada para evitar bloqueos:

```typescript
// Configuración de CORS y seguridad
async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // Configurar CORS
  app.enableCors({
    origin: process.env.ALLOWED_ORIGINS?.split(',') || '*',
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
    allowedHeaders: ['Content-Type', 'Authorization'],
    credentials: true,
  });

  // Configurar helmet para seguridad
  app.use(helmet({
    contentSecurityPolicy: false, // Ajustar según necesidades
  }));

  // Rate limiting
  app.use(rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutos
    max: 100, // límite de requests por ventana
  }));

  await app.listen(process.env.PORT || 3000, '0.0.0.0');
}
```

Configurar headers de seguridad en Kubernetes:

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: rattlesnake-develop-ingress
  annotations:
    nginx.ingress.kubernetes.io/configuration-snippet: |
      add_header X-Frame-Options "SAMEORIGIN" always;
      add_header X-Content-Type-Options "nosniff" always;
      add_header X-XSS-Protection "1; mode=block" always;
```

</TroubleshootingItem>

## Lista de Verificación para Resolución

### Verificaciones Inmediatas

- [ ] Verificar que los pods estén en estado `Running` y `Ready`
- [ ] Confirmar que el puerto de la aplicación coincida con el `targetPort` del servicio
- [ ] Probar conectividad directa al pod usando `port-forward`
- [ ] Verificar logs de la aplicación para errores de inicio
- [ ] Confirmar que las variables de entorno estén configuradas correctamente

### Verificaciones de Configuración

- [ ] Validar configuración del servicio Kubernetes
- [ ] Revisar configuración del Ingress
- [ ] Verificar sondas de salud (liveness/readiness)
- [ ] Confirmar configuración de CORS si es necesario
- [ ] Validar conectividad a la base de datos

### Verificaciones Avanzadas

- [ ] Revisar logs del controlador de Ingress
- [ ] Verificar métricas de recursos (CPU/memoria)
- [ ] Confirmar configuración de timeouts
- [ ] Validar configuración de seguridad
- [ ] Revisar configuración de red y DNS

## Mejores Prácticas

### Desarrollo

1. **Siempre enlazar a `0.0.0.0`** en aplicaciones contenerizadas
2. **Implementar health checks robustos** que verifiquen dependencias
3. **Configurar logging detallado** para facilitar debugging
4. **Usar variables de entorno** para toda la configuración

### Despliegue

1. **Configurar sondas apropiadas** con timeouts realistas
2. **Establecer límites de recursos** para evitar problemas de rendimiento
3. **Implementar monitoreo** de métricas clave
4. **Documentar configuración** específica del entorno

### Operaciones

1. **Monitorear logs regularmente** para detectar patrones
2. **Configurar alertas** para errores 502
3. **Mantener runbooks** para resolución rápida
4. **Realizar pruebas de conectividad** periódicas

---

_Esta sección de preguntas frecuentes fue generada automáticamente el 15 de enero de 2025 basada en una consulta real de usuario._
